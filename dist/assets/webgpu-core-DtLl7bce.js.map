{"version":3,"file":"webgpu-core-DtLl7bce.js","sources":["../../src/types/constants.ts","../../src/core/WebGPUContext.ts","../../src/core/SatelliteGPUBuffer.ts"],"sourcesContent":["/**\n * Grok Zephyr - Simulation Constants\n */\n\nimport type { SimulationConstants, ViewModeConfig } from './index.js';\n\n/** Satellite and orbital constants */\nexport const CONSTANTS: SimulationConstants = {\n  NUM_SATELLITES: 1048576,    // 2^20 satellites\n  EARTH_RADIUS_KM: 6371.0,    // km - Earth radius\n  ORBIT_RADIUS_KM: 6921.0,    // km - 550km altitude orbit\n  CAMERA_RADIUS_KM: 7091.0,   // km - 720km altitude camera\n  MEAN_MOTION: 0.001097,      // rad/s - orbital angular velocity\n  NUM_PLANES: 1024,           // orbital planes\n  SATELLITES_PER_PLANE: 1024, // satellites per plane\n} as const;\n\n/** Math constants */\nexport const MATH = {\n  DEG_TO_RAD: Math.PI / 180,\n  RAD_TO_DEG: 180 / Math.PI,\n  TWO_PI: Math.PI * 2,\n  HALF_PI: Math.PI / 2,\n} as const;\n\n/** Inclination shells for Walker constellation */\nexport const INCLINATION_SHELLS = [\n  53 * MATH.DEG_TO_RAD,    // 53째 - main Starlink shell\n  70 * MATH.DEG_TO_RAD,    // 70째 - polar coverage\n  97.6 * MATH.DEG_TO_RAD,  // 97.6째 - sun-synchronous\n  30 * MATH.DEG_TO_RAD,    // 30째 - equatorial\n] as const;\n\n/** View mode configurations */\nexport const VIEW_MODES: ViewModeConfig[] = [\n  { id: 0, name: '720km Horizon', altitude: '720', default: true },\n  { id: 1, name: 'God View', altitude: '---', default: false },\n  { id: 2, name: 'Fleet POV', altitude: '550', default: false },\n  { id: 3, name: 'Ground View', altitude: '0', default: false },\n] as const;\n\n/** Camera settings */\nexport const CAMERA = {\n  DEFAULT_FOV: 60 * MATH.DEG_TO_RAD,\n  NEAR_PLANE: 10,\n  FAR_PLANE: 50000,\n  GOD_VIEW_DISTANCE: 25000,\n  GOD_VIEW_MIN_DISTANCE: 8000,\n  GOD_VIEW_MAX_DISTANCE: 60000,\n} as const;\n\n/** Rendering settings */\nexport const RENDER = {\n  HDR_FORMAT: 'rgba16float' as GPUTextureFormat,\n  DEPTH_FORMAT: 'depth24plus' as GPUTextureFormat,\n  SWAPCHAIN_FORMAT: 'bgra8unorm' as GPUTextureFormat,\n  BLOOM_THRESHOLD: 0.75,\n  BLOOM_INTENSITY: 1.8,\n  WORKGROUP_SIZE: 64,\n} as const;\n\n/** Culling distances */\nexport const CULLING = {\n  /** Max distance for satellite rendering (km) */\n  MAX_DISTANCE: 14000.0,\n  /** Frustum culling margin (km) */\n  FRUSTUM_MARGIN: 200.0,\n} as const;\n\n/** Satellite visual settings */\nexport const SATELLITE_VISUAL = {\n  /** Number of color variations */\n  COLOR_COUNT: 7,\n  /** Base billboard size in km at reference distance */\n  BASE_SIZE: 1200.0,\n  /** Reference distance for size calculation */\n  REF_DISTANCE: 50.0,\n  /** Minimum billboard size */\n  MIN_SIZE: 0.4,\n  /** Maximum billboard size */\n  MAX_SIZE: 60.0,\n  /** Attenuation factor */\n  ATTENUATION: 0.00075,\n} as const;\n\n/** Earth visual settings */\nexport const EARTH_VISUAL = {\n  SPHERE_SEGMENTS: 64,\n  SPHERE_RINGS: 64,\n  ATMOSPHERE_SCALE: 6471.0 / 6371.0, // 100km atmosphere\n} as const;\n\n/** UI update intervals (seconds) */\nexport const UI = {\n  FPS_UPDATE_INTERVAL: 0.5,\n  STATS_UPDATE_INTERVAL: 1.0,\n} as const;\n\n/** Buffer sizes */\nexport const BUFFER_SIZES = {\n  UNIFORM: 256,           // 256 bytes aligned\n  BLOOM_UNIFORM: 32,      // 32 bytes for bloom params\n  SATELLITE_DATA: 16,     // vec4f per satellite\n  ORBITAL_ELEMENT: 16,    // vec4f per satellite\n} as const;\n","/**\n * Grok Zephyr - WebGPU Context Manager\n * \n * Handles WebGPU adapter and device initialization,\n * canvas context setup, and error handling.\n */\n\nimport { CONSTANTS, RENDER } from '@/types/constants.js';\n\n/** WebGPU context initialization result */\nexport interface WebGPUInitResult {\n  device: GPUDevice;\n  adapter: GPUAdapter;\n  context: GPUCanvasContext;\n  format: GPUTextureFormat;\n  presentationFormat: GPUTextureFormat;\n}\n\n/** WebGPU context options */\nexport interface WebGPUContextOptions {\n  powerPreference?: GPUPowerPreference;\n  requiredFeatures?: GPUFeatureName[];\n  requiredLimits?: Record<string, number>;\n}\n\n/**\n * WebGPU Context Manager\n * \n * Handles initialization of the WebGPU environment including:\n * - Adapter and device creation\n * - Canvas context configuration\n * - Feature detection and limits\n */\nexport class WebGPUContext {\n  private device: GPUDevice | null = null;\n  private adapter: GPUAdapter | null = null;\n  private context: GPUCanvasContext | null = null;\n  private format: GPUTextureFormat = RENDER.SWAPCHAIN_FORMAT;\n  private canvas: HTMLCanvasElement;\n  private options: WebGPUContextOptions;\n  private lostHandler: ((info: GPUDeviceLostInfo) => void) | null = null;\n\n  constructor(canvas: HTMLCanvasElement, options: WebGPUContextOptions = {}) {\n    this.canvas = canvas;\n    this.options = {\n      powerPreference: 'high-performance',\n      requiredFeatures: [],\n      ...options,\n    };\n  }\n\n  /**\n   * Check if WebGPU is supported in the current browser\n   */\n  static isSupported(): boolean {\n    return typeof navigator !== 'undefined' && 'gpu' in navigator;\n  }\n\n  /**\n   * Initialize WebGPU context\n   * @throws Error if WebGPU is not supported or initialization fails\n   */\n  async initialize(): Promise<WebGPUInitResult> {\n    if (!WebGPUContext.isSupported()) {\n      throw new WebGPUError(\n        'WebGPU is not supported in this browser. ' +\n        'Please use Chrome 113+, Edge 113+, or Firefox Nightly with WebGPU enabled.'\n      );\n    }\n\n    try {\n      // Request adapter\n      this.adapter = await navigator.gpu.requestAdapter({\n        powerPreference: this.options.powerPreference,\n      });\n\n      if (!this.adapter) {\n        throw new WebGPUError('No WebGPU adapter found. Your GPU may not support WebGPU.');\n      }\n\n      // Log adapter info for debugging\n      // Use adapter.info (new spec) with fallback to requestAdapterInfo (old spec)\n      let adapterInfo: GPUAdapterInfo | undefined;\n      if (this.adapter.info) {\n        adapterInfo = this.adapter.info;\n      } else if (typeof (this.adapter as any).requestAdapterInfo === 'function') {\n        try {\n          adapterInfo = await (this.adapter as any).requestAdapterInfo();\n        } catch {\n          // Ignore errors from deprecated API\n        }\n      }\n      if (adapterInfo) {\n        console.log('[WebGPU] Adapter:', adapterInfo.vendor, adapterInfo.architecture);\n      }\n\n      // Calculate required buffer sizes for 1M satellites\n      const requiredStorageSize = CONSTANTS.NUM_SATELLITES * 16 + 16;\n\n      // Request device with appropriate limits\n      this.device = await this.adapter.requestDevice({\n        requiredFeatures: this.options.requiredFeatures,\n        requiredLimits: {\n          maxStorageBufferBindingSize: Math.min(\n            this.adapter.limits.maxStorageBufferBindingSize,\n            requiredStorageSize\n          ),\n          maxBufferSize: Math.min(\n            this.adapter.limits.maxBufferSize,\n            requiredStorageSize\n          ),\n          ...this.options.requiredLimits,\n        },\n      });\n\n      // Handle device loss\n      this.lostHandler = (info) => {\n        console.error('[WebGPU] Device lost:', info.reason, info.message);\n        if (info.reason === 'destroyed') {\n          console.log('[WebGPU] Device was intentionally destroyed');\n        } else {\n          // Attempt recovery\n          console.log('[WebGPU] Attempting to reinitialize...');\n          this.initialize().catch(console.error);\n        }\n      };\n      this.device.lost.then(this.lostHandler);\n\n      // Setup canvas context\n      this.context = this.canvas.getContext('webgpu');\n      if (!this.context) {\n        throw new WebGPUError('Failed to create WebGPU canvas context');\n      }\n\n      // Get preferred canvas format\n      this.format = navigator.gpu.getPreferredCanvasFormat();\n\n      // Configure context\n      this.context.configure({\n        device: this.device,\n        format: this.format,\n        alphaMode: 'opaque',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,\n      });\n\n      console.log('[WebGPU] Context initialized successfully');\n      console.log(`[WebGPU] Format: ${this.format}`);\n      console.log(`[WebGPU] Max storage buffer: ${this.device.limits.maxStorageBufferBindingSize} bytes`);\n\n      return {\n        device: this.device,\n        adapter: this.adapter,\n        context: this.context,\n        format: this.format,\n        presentationFormat: this.format,\n      };\n    } catch (error) {\n      if (error instanceof WebGPUError) {\n        throw error;\n      }\n      throw new WebGPUError(\n        `Failed to initialize WebGPU: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Get the GPU device\n   */\n  getDevice(): GPUDevice {\n    if (!this.device) {\n      throw new WebGPUError('WebGPU not initialized. Call initialize() first.');\n    }\n    return this.device;\n  }\n\n  /**\n   * Get the GPU adapter\n   */\n  getAdapter(): GPUAdapter {\n    if (!this.adapter) {\n      throw new WebGPUError('WebGPU not initialized. Call initialize() first.');\n    }\n    return this.adapter;\n  }\n\n  /**\n   * Get the canvas context\n   */\n  getContext(): GPUCanvasContext {\n    if (!this.context) {\n      throw new WebGPUError('WebGPU not initialized. Call initialize() first.');\n    }\n    return this.context;\n  }\n\n  /**\n   * Get the swapchain format\n   */\n  getFormat(): GPUTextureFormat {\n    return this.format;\n  }\n\n  /**\n   * Create a shader module from WGSL code\n   */\n  createShaderModule(code: string, label?: string): GPUShaderModule {\n    const device = this.getDevice();\n    const module = device.createShaderModule({\n      code,\n      label,\n    });\n\n    // Check for compilation errors\n    module.getCompilationInfo().then((info) => {\n      for (const message of info.messages) {\n        const location = message.lineNum > 0 ? `:${message.lineNum}:${message.linePos}` : '';\n        const text = `[Shader${location}] ${message.message}`;\n        if (message.type === 'error') {\n          console.error(text);\n        } else if (message.type === 'warning') {\n          console.warn(text);\n        } else {\n          console.log(text);\n        }\n      }\n    });\n\n    return module;\n  }\n\n  /**\n   * Create a buffer with proper alignment\n   */\n  createBuffer(\n    size: number,\n    usage: GPUBufferUsageFlags,\n    mappedAtCreation = false\n  ): GPUBuffer {\n    const device = this.getDevice();\n    // Align to 256 bytes for uniform buffers\n    const alignedSize = usage & GPUBufferUsage.UNIFORM\n      ? Math.ceil(size / 256) * 256\n      : size;\n    \n    return device.createBuffer({\n      size: alignedSize,\n      usage,\n      mappedAtCreation,\n    });\n  }\n\n  /**\n   * Create a uniform buffer\n   */\n  createUniformBuffer(size: number): GPUBuffer {\n    return this.createBuffer(size, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);\n  }\n\n  /**\n   * Create a storage buffer\n   */\n  createStorageBuffer(size: number, readOnly = false): GPUBuffer {\n    const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;\n    if (!readOnly) {\n      return this.createBuffer(size, usage | GPUBufferUsage.COPY_SRC);\n    }\n    return this.createBuffer(size, usage);\n  }\n\n  /**\n   * Create a vertex buffer\n   */\n  createVertexBuffer(size: number): GPUBuffer {\n    return this.createBuffer(\n      size,\n      GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\n    );\n  }\n\n  /**\n   * Create an index buffer\n   */\n  createIndexBuffer(size: number): GPUBuffer {\n    return this.createBuffer(\n      size,\n      GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST\n    );\n  }\n\n  /**\n   * Write data to a buffer\n   */\n  writeBuffer(\n    buffer: GPUBuffer,\n    data: BufferSource,\n    offset = 0\n  ): void {\n    this.getDevice().queue.writeBuffer(buffer, offset, data);\n  }\n\n  /**\n   * Create a texture with standard usage\n   */\n  createTexture(\n    width: number,\n    height: number,\n    format: GPUTextureFormat,\n    usage: GPUTextureUsageFlags,\n    label?: string\n  ): GPUTexture {\n    return this.getDevice().createTexture({\n      size: [width, height],\n      format,\n      usage: usage | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,\n      label,\n    });\n  }\n\n  /**\n   * Create a linear sampler with clamp-to-edge\n   */\n  createLinearSampler(): GPUSampler {\n    return this.getDevice().createSampler({\n      magFilter: 'linear',\n      minFilter: 'linear',\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n    });\n  }\n\n  /**\n   * Create a command encoder\n   */\n  createCommandEncoder(label?: string): GPUCommandEncoder {\n    return this.getDevice().createCommandEncoder({ label });\n  }\n\n  /**\n   * Submit command buffers\n   */\n  submit(commandBuffers: GPUCommandBuffer[]): void {\n    this.getDevice().queue.submit(commandBuffers);\n  }\n\n  /**\n   * Resize canvas and context\n   */\n  resize(width: number, height: number): void {\n    if (this.canvas.width !== width || this.canvas.height !== height) {\n      this.canvas.width = width;\n      this.canvas.height = height;\n      // Context automatically handles resize\n    }\n  }\n\n  /**\n   * Get current canvas size\n   */\n  getCanvasSize(): { width: number; height: number } {\n    return {\n      width: this.canvas.width,\n      height: this.canvas.height,\n    };\n  }\n\n  /**\n   * Check if a feature is supported\n   */\n  async isFeatureSupported(feature: GPUFeatureName): Promise<boolean> {\n    if (!this.adapter) {\n      throw new WebGPUError('WebGPU not initialized');\n    }\n    return this.adapter.features.has(feature);\n  }\n\n  /**\n   * Destroy and cleanup resources\n   */\n  destroy(): void {\n    if (this.device) {\n      this.device.destroy();\n      this.device = null;\n    }\n    this.adapter = null;\n    this.context = null;\n    this.lostHandler = null;\n  }\n}\n\n/**\n * Custom WebGPU error class\n */\nexport class WebGPUError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'WebGPUError';\n  }\n}\n\nexport default WebGPUContext;\n","/**\n * Grok Zephyr - Satellite GPU Buffer Manager\n * \n * Manages GPU buffers for 1M+ satellites with double-buffering\n * for efficient compute/graphics interop.\n */\n\nimport type WebGPUContext from './WebGPUContext.js';\nimport { CONSTANTS, BUFFER_SIZES, INCLINATION_SHELLS } from '@/types/constants.js';\n\n/** Buffer pair for double-buffering */\nexport interface BufferPair {\n  read: GPUBuffer;\n  write: GPUBuffer;\n  current: 'read' | 'write';\n}\n\n/** Satellite buffer configuration */\nexport interface SatelliteBufferConfig {\n  /** Enable double-buffering for ping-pong rendering */\n  doubleBuffer: boolean;\n  /** Enable CPU readback (for debug/visualization) */\n  enableReadback: boolean;\n  /** Buffer usage flags */\n  usage: GPUBufferUsageFlags;\n}\n\n/** GPU buffer set for satellite data */\nexport interface SatelliteBufferSet {\n  /** Orbital elements (read-only storage) */\n  orbitalElements: GPUBuffer;\n  /** Satellite positions (read-write storage) */\n  positions: GPUBuffer | BufferPair;\n  /** Uniform buffer for frame data */\n  uniforms: GPUBuffer;\n  /** Bloom uniform buffers (H and V passes) */\n  bloomUniforms: {\n    horizontal: GPUBuffer;\n    vertical: GPUBuffer;\n  };\n}\n\n/**\n * Satellite GPU Buffer Manager\n * \n * Efficiently manages GPU memory for massive satellite constellations:\n * - Separate orbital elements buffer (read-only)\n * - Position buffer with optional double-buffering\n * - Uniform buffer for frame data\n * - Optimized memory layout for 1M+ satellites\n */\nexport class SatelliteGPUBuffer {\n  private context: WebGPUContext;\n  private config: SatelliteBufferConfig;\n  \n  // Buffer storage\n  private buffers: SatelliteBufferSet | null = null;\n  private orbitalElementData: Float32Array;\n  \n  // Cached sizes\n  private readonly numSatellites: number;\n  private readonly positionBufferSize: number;\n  private readonly elementBufferSize: number;\n\n  constructor(\n    context: WebGPUContext,\n    config: Partial<SatelliteBufferConfig> = {}\n  ) {\n    this.context = context;\n    this.config = {\n      doubleBuffer: false,\n      enableReadback: false,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      ...config,\n    };\n    \n    this.numSatellites = CONSTANTS.NUM_SATELLITES;\n    this.positionBufferSize = this.numSatellites * BUFFER_SIZES.SATELLITE_DATA;\n    this.elementBufferSize = this.numSatellites * BUFFER_SIZES.ORBITAL_ELEMENT;\n    \n    // Pre-allocate orbital element data on CPU\n    this.orbitalElementData = new Float32Array(this.numSatellites * 4);\n  }\n\n  /**\n   * Initialize all GPU buffers\n   */\n  initialize(): SatelliteBufferSet {\n    console.log(`[SatelliteGPUBuffer] Initializing buffers for ${this.numSatellites.toLocaleString()} satellites`);\n    console.log(`[SatelliteGPUBuffer] Position buffer: ${(this.positionBufferSize / 1024 / 1024).toFixed(2)} MB`);\n    console.log(`[SatelliteGPUBuffer] Element buffer: ${(this.elementBufferSize / 1024 / 1024).toFixed(2)} MB`);\n\n    // Create orbital elements buffer (read-only)\n    const orbitalElements = this.context.createBuffer(\n      this.elementBufferSize,\n      GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n    );\n\n    // Create position buffer(s)\n    let positions: GPUBuffer | BufferPair;\n    if (this.config.doubleBuffer) {\n      positions = {\n        read: this.context.createStorageBuffer(this.positionBufferSize),\n        write: this.context.createStorageBuffer(this.positionBufferSize),\n        current: 'read',\n      };\n    } else {\n      positions = this.context.createStorageBuffer(this.positionBufferSize);\n    }\n\n    // Create uniform buffer (256 bytes, aligned)\n    const uniforms = this.context.createUniformBuffer(BUFFER_SIZES.UNIFORM);\n\n    // Create bloom uniform buffers\n    const bloomUniforms = {\n      horizontal: this.context.createUniformBuffer(BUFFER_SIZES.BLOOM_UNIFORM),\n      vertical: this.context.createUniformBuffer(BUFFER_SIZES.BLOOM_UNIFORM),\n    };\n\n    this.buffers = {\n      orbitalElements,\n      positions,\n      uniforms,\n      bloomUniforms,\n    };\n\n    return this.buffers;\n  }\n\n  /**\n   * Generate Walker constellation orbital elements\n   * \n   * Creates a evenly distributed constellation across multiple\n   * inclination shells similar to Starlink.\n   */\n  generateOrbitalElements(): Float32Array {\n    const { NUM_PLANES, SATELLITES_PER_PLANE } = CONSTANTS;\n    const shells = INCLINATION_SHELLS;\n    \n    console.log(`[SatelliteGPUBuffer] Generating orbital elements...`);\n    const startTime = performance.now();\n\n    for (let plane = 0; plane < NUM_PLANES; plane++) {\n      const raan = (plane / NUM_PLANES) * Math.PI * 2;\n      const shellIndex = Math.floor(plane / (NUM_PLANES / shells.length));\n      const inclination = shells[shellIndex] + (Math.random() - 0.5) * 0.008;\n\n      for (let sat = 0; sat < SATELLITES_PER_PLANE; sat++) {\n        const idx = (plane * SATELLITES_PER_PLANE + sat) * 4;\n        const meanAnomaly = (sat / SATELLITES_PER_PLANE) * Math.PI * 2;\n\n        // Store as vec4f: [raan, inclination, meanAnomaly, colorIndex]\n        this.orbitalElementData[idx + 0] = raan;\n        this.orbitalElementData[idx + 1] = inclination;\n        this.orbitalElementData[idx + 2] = meanAnomaly;\n        // Color index: rainbow by plane (0-6)\n        this.orbitalElementData[idx + 3] = Math.floor((plane * 7) / NUM_PLANES);\n      }\n    }\n\n    const elapsed = performance.now() - startTime;\n    console.log(`[SatelliteGPUBuffer] Generated elements in ${elapsed.toFixed(2)}ms`);\n\n    return this.orbitalElementData;\n  }\n\n  /**\n   * Upload orbital elements to GPU\n   */\n  uploadOrbitalElements(): void {\n    if (!this.buffers) {\n      throw new Error('Buffers not initialized. Call initialize() first.');\n    }\n    this.context.writeBuffer(this.buffers.orbitalElements, this.orbitalElementData);\n  }\n\n  /**\n   * Update bloom uniforms for current resolution\n   */\n  updateBloomUniforms(width: number, height: number): void {\n    if (!this.buffers) return;\n\n    const createData = (horizontal: boolean): ArrayBuffer => {\n      const buffer = new ArrayBuffer(32);\n      const f32 = new Float32Array(buffer);\n      const u32 = new Uint32Array(buffer);\n      f32[0] = 1 / width;\n      f32[1] = 1 / height;\n      u32[2] = horizontal ? 1 : 0;\n      u32[3] = 0;\n      return buffer;\n    };\n\n    this.context.writeBuffer(\n      this.buffers.bloomUniforms.horizontal,\n      createData(true)\n    );\n    this.context.writeBuffer(\n      this.buffers.bloomUniforms.vertical,\n      createData(false)\n    );\n  }\n\n  /**\n   * Get the current position buffer (for rendering)\n   */\n  getPositionBufferForRender(): GPUBuffer {\n    if (!this.buffers) {\n      throw new Error('Buffers not initialized');\n    }\n    \n    if (this.isBufferPair(this.buffers.positions)) {\n      return this.buffers.positions.current === 'read'\n        ? this.buffers.positions.read\n        : this.buffers.positions.write;\n    }\n    \n    return this.buffers.positions;\n  }\n\n  /**\n   * Get the current position buffer (for compute)\n   */\n  getPositionBufferForCompute(): GPUBuffer {\n    if (!this.buffers) {\n      throw new Error('Buffers not initialized');\n    }\n    \n    if (this.isBufferPair(this.buffers.positions)) {\n      return this.buffers.positions.current === 'read'\n        ? this.buffers.positions.write\n        : this.buffers.positions.read;\n    }\n    \n    return this.buffers.positions;\n  }\n\n  /**\n   * Swap double buffers (ping-pong)\n   */\n  swapBuffers(): void {\n    if (!this.buffers || !this.isBufferPair(this.buffers.positions)) {\n      return;\n    }\n    \n    this.buffers.positions.current =\n      this.buffers.positions.current === 'read' ? 'write' : 'read';\n  }\n\n  /**\n   * Get all buffers\n   */\n  getBuffers(): SatelliteBufferSet {\n    if (!this.buffers) {\n      throw new Error('Buffers not initialized. Call initialize() first.');\n    }\n    return this.buffers;\n  }\n\n  /**\n   * Get orbital element data (for CPU-side calculations)\n   */\n  getOrbitalElementData(): Float32Array {\n    return this.orbitalElementData;\n  }\n\n  /**\n   * Calculate satellite position on CPU (for camera tracking)\n   */\n  calculateSatellitePosition(index: number, time: number): [number, number, number] {\n    const i = index * 4;\n    const raan = this.orbitalElementData[i];\n    const inclination = this.orbitalElementData[i + 1];\n    const meanAnomaly0 = this.orbitalElementData[i + 2];\n    \n    const meanAnomaly = meanAnomaly0 + CONSTANTS.MEAN_MOTION * time;\n    \n    const cM = Math.cos(meanAnomaly);\n    const sM = Math.sin(meanAnomaly);\n    const cR = Math.cos(raan);\n    const sR = Math.sin(raan);\n    const cI = Math.cos(inclination);\n    const sI = Math.sin(inclination);\n\n    return [\n      CONSTANTS.ORBIT_RADIUS_KM * (cR * cM - sR * sM * cI),\n      CONSTANTS.ORBIT_RADIUS_KM * (sR * cM + cR * sM * cI),\n      CONSTANTS.ORBIT_RADIUS_KM * sM * sI,\n    ];\n  }\n\n  /**\n   * Calculate satellite velocity on CPU\n   */\n  calculateSatelliteVelocity(index: number, time: number): [number, number, number] {\n    const i = index * 4;\n    const raan = this.orbitalElementData[i];\n    const inclination = this.orbitalElementData[i + 1];\n    const meanAnomaly0 = this.orbitalElementData[i + 2];\n    \n    const meanAnomaly = meanAnomaly0 + CONSTANTS.MEAN_MOTION * time;\n    \n    const cM = Math.cos(meanAnomaly);\n    const sM = Math.sin(meanAnomaly);\n    const cR = Math.cos(raan);\n    const sR = Math.sin(raan);\n    const cI = Math.cos(inclination);\n    const sI = Math.sin(inclination);\n\n    // dpos/dM (normalized velocity direction)\n    const vx = -(cR * sM + sR * cM * cI);\n    const vy = -(sR * sM - cR * cM * cI);\n    const vz = cM * sI;\n    \n    const len = Math.sqrt(vx * vx + vy * vy + vz * vz) || 1;\n    return [vx / len, vy / len, vz / len];\n  }\n\n  /**\n   * Read position data back from GPU (async)\n   */\n  async readbackPositions(): Promise<Float32Array | null> {\n    if (!this.buffers || !this.config.enableReadback) {\n      return null;\n    }\n\n    const device = this.context.getDevice();\n    const positionBuffer = this.getPositionBufferForRender();\n    \n    // Create staging buffer for readback\n    const stagingBuffer = device.createBuffer({\n      size: this.positionBufferSize,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    // Encode copy command\n    const encoder = device.createCommandEncoder();\n    encoder.copyBufferToBuffer(\n      positionBuffer,\n      0,\n      stagingBuffer,\n      0,\n      this.positionBufferSize\n    );\n    device.queue.submit([encoder.finish()]);\n\n    // Map and read\n    await stagingBuffer.mapAsync(GPUMapMode.READ);\n    const data = new Float32Array(stagingBuffer.getMappedRange().slice(0));\n    stagingBuffer.unmap();\n    stagingBuffer.destroy();\n\n    return data;\n  }\n\n  /**\n   * Calculate total GPU memory usage in bytes\n   */\n  getMemoryUsage(): number {\n    let total = this.elementBufferSize + BUFFER_SIZES.UNIFORM + BUFFER_SIZES.BLOOM_UNIFORM * 2;\n    \n    if (this.config.doubleBuffer && this.buffers && this.isBufferPair(this.buffers.positions)) {\n      total += this.positionBufferSize * 2;\n    } else {\n      total += this.positionBufferSize;\n    }\n    \n    return total;\n  }\n\n  /**\n   * Destroy and cleanup all buffers\n   */\n  destroy(): void {\n    if (this.buffers) {\n      this.buffers.orbitalElements.destroy();\n      this.buffers.uniforms.destroy();\n      this.buffers.bloomUniforms.horizontal.destroy();\n      this.buffers.bloomUniforms.vertical.destroy();\n      \n      if (this.isBufferPair(this.buffers.positions)) {\n        this.buffers.positions.read.destroy();\n        this.buffers.positions.write.destroy();\n      } else {\n        this.buffers.positions.destroy();\n      }\n      \n      this.buffers = null;\n    }\n  }\n\n  /**\n   * Type guard for BufferPair\n   */\n  private isBufferPair(buffer: GPUBuffer | BufferPair): buffer is BufferPair {\n    return 'read' in buffer && 'write' in buffer;\n  }\n}\n\nexport default SatelliteGPUBuffer;\n"],"names":["CONSTANTS","MATH","INCLINATION_SHELLS","VIEW_MODES","CAMERA","RENDER","UI","BUFFER_SIZES","WebGPUContext","canvas","options","__publicField","WebGPUError","adapterInfo","requiredStorageSize","info","error","code","label","module","message","text","size","usage","mappedAtCreation","device","alignedSize","readOnly","buffer","data","offset","width","height","format","commandBuffers","feature","SatelliteGPUBuffer","context","config","orbitalElements","positions","uniforms","bloomUniforms","NUM_PLANES","SATELLITES_PER_PLANE","shells","startTime","plane","raan","shellIndex","inclination","sat","idx","meanAnomaly","elapsed","createData","horizontal","f32","u32","index","time","cM","sM","cR","sR","cI","sI","vx","vy","vz","len","positionBuffer","stagingBuffer","encoder","total"],"mappings":"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"}
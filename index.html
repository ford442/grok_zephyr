<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Colossus Fleet – WebGPU Simulation</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;overflow:hidden;font-family:'Courier New',monospace;color:#0f0}
#canvas{display:block;width:100vw;height:100vh}
#ui{position:fixed;top:16px;left:16px;z-index:10;pointer-events:none;text-shadow:0 0 8px #00ff88}
.stat{font-size:13px;line-height:1.8;color:#00ff88}
.title{font-size:15px;font-weight:bold;color:#fff;text-shadow:0 0 12px #00aaff;margin-bottom:4px}
#controls{position:fixed;bottom:18px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:10}
.vbtn{background:rgba(0,255,136,.08);border:1px solid #00ff88;color:#00ff88;padding:7px 18px;
  cursor:pointer;font-family:'Courier New',monospace;font-size:11px;letter-spacing:1px;
  transition:background .2s,box-shadow .2s}
.vbtn:hover,.vbtn.active{background:rgba(0,255,136,.25);box-shadow:0 0 12px #00ff8855}
#error{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#f44;font-size:18px;
  text-align:center;line-height:1.6;display:none;max-width:500px}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
  <div class="title">◈ COLOSSUS FLEET</div>
  <div class="stat" id="s-alt">Altitude : 720 km</div>
  <div class="stat" id="s-fleet">Fleet    : 1,048,576</div>
  <div class="stat" id="s-fps">FPS      : --</div>
  <div class="stat" id="s-view">View     : 720km Horizon</div>
</div>
<div id="controls">
  <button class="vbtn active" id="btn0" onclick="sim&&sim.setView(0)">720km HORIZON</button>
  <button class="vbtn"        id="btn1" onclick="sim&&sim.setView(1)">GOD VIEW</button>
  <button class="vbtn"        id="btn2" onclick="sim&&sim.setView(2)">FLEET POV</button>
</div>
<div id="error"></div>

<script>
'use strict';
/* ============================================================
   CONSTANTS
   ============================================================ */
const NUM_SAT       = 1048576;   // 2^20 = 1 M
const EARTH_R       = 6371.0;    // km
const ORBIT_R       = 6921.0;    // km  (550 km altitude)
const CAM_R         = 7091.0;    // km  (720 km altitude)
const MEAN_MOTION   = 0.001097;  // rad/s  = sqrt(μ/a³)
const DEG           = Math.PI / 180;
const NUM_PLANES    = 1024;
const SAT_PER_PLANE = 1024;      // 1024×1024 = 1 048 576

/* ============================================================
   WGSL – UNIFORM STRUCT (shared header embedded in each shader)
   ============================================================ */
const UNI_STRUCT = /* wgsl */`
struct Uni {
  view_proj      : mat4x4f,       // offset   0  size 64
  camera_pos     : vec4f,         // offset  64  size 16
  camera_right   : vec4f,         // offset  80  size 16
  camera_up      : vec4f,         // offset  96  size 16
  time           : f32,           // offset 112
  delta_time     : f32,           // offset 116
  view_mode      : u32,           // offset 120
  pad0           : u32,           // offset 124
  frustum        : array<vec4f,6>,// offset 128  size 96
  screen_size    : vec2f,         // offset 224
  pad1           : vec2f,         // offset 232
};                                // total  240 → buffer 256
@group(0) @binding(0) var<uniform> uni : Uni;
`;

/* ============================================================
   WGSL – ORBITAL COMPUTE SHADER
   ============================================================ */
const ORBITAL_CS = UNI_STRUCT + /* wgsl */`
@group(0) @binding(1) var<storage,read>       orb_elem : array<vec4f>;
@group(0) @binding(2) var<storage,read_write> sat_pos  : array<vec4f>;

const ORBIT_KM    : f32 = 6921.0;
const MEAN_MOTION : f32 = 0.001097;

@compute @workgroup_size(64,1,1)
fn main(@builtin(global_invocation_id) gid : vec3u) {
  let i = gid.x;
  if (i >= 1048576u) { return; }

  let e    = orb_elem[i];
  let raan = e.x;
  let inc  = e.y;
  let m0   = e.z;
  let cdat = e.w;

  let M  = m0 + MEAN_MOTION * uni.time;
  let cM = cos(M); let sM = sin(M);
  let cR = cos(raan); let sR = sin(raan);
  let cI = cos(inc);  let sI = sin(inc);

  let x = ORBIT_KM * (cR*cM - sR*sM*cI);
  let y = ORBIT_KM * (sR*cM + cR*sM*cI);
  let z = ORBIT_KM * sM * sI;

  sat_pos[i] = vec4f(x, y, z, cdat);
}
`;

/* ============================================================
   WGSL – STARS BACKGROUND (fullscreen triangle)
   ============================================================ */
const STARS_SHADER = UNI_STRUCT + /* wgsl */`
struct VSOut { @builtin(position) pos:vec4f, @location(0) uv:vec2f };

@vertex fn vs(@builtin(vertex_index) vi:u32) -> VSOut {
  const pts = array<vec2f,3>(vec2f(-1,-1),vec2f(3,-1),vec2f(-1,3));
  var o:VSOut;
  o.pos = vec4f(pts[vi],0,1);
  o.uv  = pts[vi]*0.5 + 0.5;
  return o;
}

fn hash(n:f32)->f32 { return fract(sin(n)*43758.5453); }
fn hash2(p:vec2f)->f32 {
  return fract(sin(dot(p,vec2f(127.1,311.7)))*43758.5453);
}

@fragment fn fs(in:VSOut) -> @location(0) vec4f {
  // Simple star field: tile in screen-space angular bins
  let cell  = floor(in.uv * 512.0);
  let h     = hash2(cell);
  let h2    = hash2(cell + vec2f(1.0,0.0));
  let h3    = hash2(cell + vec2f(0.0,1.0));
  let star  = f32(h > 0.994) * pow(h2,6.0);
  let color = mix(vec3f(0.6,0.8,1.0), vec3f(1.0,0.9,0.7), h3);
  return vec4f(color * star * 1.5, 1.0);
}
`;

/* ============================================================
   WGSL – EARTH SPHERE
   ============================================================ */
const EARTH_SHADER = UNI_STRUCT + /* wgsl */`
struct VIn  { @location(0) pos:vec3f, @location(1) nrm:vec3f }
struct VOut { @builtin(position) cp:vec4f, @location(0) wp:vec3f,
              @location(1) n:vec3f }

@vertex fn vs(v:VIn) -> VOut {
  var o:VOut;
  o.cp = uni.view_proj * vec4f(v.pos,1);
  o.wp = v.pos;
  o.n  = v.nrm;
  return o;
}

fn hash2e(p:vec2f)->f32 {
  return fract(sin(dot(p,vec2f(127.1,311.7)))*43758.5453);
}

@fragment fn fs(in:VOut) -> @location(0) vec4f {
  let N       = normalize(in.n);
  let sun_dir = normalize(vec3f(1.0,0.4,0.2));
  let diff    = max(dot(N,sun_dir),0.0);

  // Pseudo land/ocean pattern from spherical harmonics
  let lat = asin(clamp(N.z,-1.0,1.0));
  let lon = atan2(N.y,N.x);
  let f1  = sin(lat*4.0+0.5)*cos(lon*3.0+1.2);
  let f2  = cos(lat*6.0)*sin(lon*5.0+0.8);
  let land = smoothstep(0.15,0.35, f1*0.6+f2*0.4);

  let ocean = vec3f(0.04,0.10,0.30);
  let soil  = vec3f(0.15,0.22,0.06);
  let ice   = vec3f(0.7,0.75,0.8);
  let pole  = smoothstep(1.1,1.4, abs(lat));
  var surf  = mix(mix(ocean,soil,land), ice, pole);

  let ambient   = 0.04;
  let lit       = surf * (diff*0.92 + ambient);

  // Night-side city lights
  let night = smoothstep(0.08,-0.08,dot(N,sun_dir));
  let city  = night * 0.025 * vec3f(1.0,0.85,0.4)
              * smoothstep(0.4,0.6,land)
              * (0.5+0.5*sin(lon*18.0+lat*14.0));

  return vec4f(lit+city,1.0);
}
`;

/* ============================================================
   WGSL – ATMOSPHERE LIMB GLOW (additive blend, larger sphere)
   ============================================================ */
const ATM_SHADER = UNI_STRUCT + /* wgsl */`
struct VIn  { @location(0) pos:vec3f, @location(1) nrm:vec3f }
struct VOut { @builtin(position) cp:vec4f, @location(0) wp:vec3f,
              @location(1) n:vec3f }

const ATM_SCALE : f32 = 6471.0/6371.0; // 100km atmosphere

@vertex fn vs(v:VIn) -> VOut {
  var o:VOut;
  let p  = v.pos * ATM_SCALE;
  o.cp   = uni.view_proj * vec4f(p,1);
  o.wp   = p;
  o.n    = v.nrm;
  return o;
}

@fragment fn fs(in:VOut) -> @location(0) vec4f {
  let N       = normalize(in.n);
  let V       = normalize(uni.camera_pos.xyz - in.wp);
  let rim     = 1.0 - abs(dot(N,V));
  let limb    = pow(rim,3.5);
  let limb2   = pow(rim,7.0);

  let blue    = vec3f(0.08,0.38,1.0)*limb*2.8;
  let teal    = vec3f(0.0,0.7,0.45)*limb2*0.6;
  let alpha   = limb*0.85;
  return vec4f(blue+teal, alpha);
}
`;

/* ============================================================
   WGSL – SATELLITE BILLBOARDS (instanced, additive blend)
   ============================================================ */
const SAT_SHADER = UNI_STRUCT + /* wgsl */`
@group(0) @binding(1) var<storage,read> sat_pos : array<vec4f>;

struct VOut {
  @builtin(position) cp : vec4f,
  @location(0) uv       : vec2f,
  @location(1) color    : vec3f,
  @location(2) bright   : f32,
}

fn sat_color(idx:u32) -> vec3f {
  let c = idx % 7u;
  if(c==0u){return vec3f(1.0,0.18,0.18);}
  if(c==1u){return vec3f(0.18,1.0,0.18);}
  if(c==2u){return vec3f(0.25,0.45,1.0);}
  if(c==3u){return vec3f(1.0,1.0,0.1);}
  if(c==4u){return vec3f(0.1,1.0,1.0);}
  if(c==5u){return vec3f(1.0,0.1,1.0);}
  return vec3f(1.0,1.0,1.0);
}

@vertex fn vs(
  @builtin(vertex_index)   vi : u32,
  @builtin(instance_index) ii : u32,
) -> VOut {
  let pd      = sat_pos[ii];
  let wp      = pd.xyz;
  let cdat    = pd.w;
  let cam     = uni.camera_pos.xyz;
  let dist    = length(wp - cam);

  // Frustum + distance cull → degenerate vertex
  var visible = true;
  if (dist > 14000.0) { visible = false; }
  if (visible) {
    for (var p=0u; p<6u; p++) {
      let pl = uni.frustum[p];
      if (dot(pl.xyz, wp) + pl.w < -200.0) { visible=false; break; }
    }
  }

  var o : VOut;
  if (!visible) {
    o.cp     = vec4f(10,10,10,1);
    o.uv     = vec2f(0);
    o.color  = vec3f(0);
    o.bright = 0.0;
    return o;
  }

  // Billboard size (km): closer → bigger, capped
  let bsize = clamp(1200.0/max(dist,50.0), 0.4, 60.0);

  const quad = array<vec2f,6>(
    vec2f(-1,-1),vec2f(1,-1),vec2f(-1,1),
    vec2f(-1, 1),vec2f(1,-1),vec2f( 1,1));

  let qv     = quad[vi];
  let right  = uni.camera_right.xyz;
  let up     = uni.camera_up.xyz;
  let offset = (qv.x*right + qv.y*up) * bsize;
  let fpos   = wp + offset;

  // Color & animated pattern
  let cidx    = u32(abs(cdat)) % 7u;
  let col     = sat_color(cidx);
  let phase   = cdat*0.15 + uni.time*(0.8+0.4*fract(f32(ii)*0.000613));
  let pattern = 0.35 + 0.65*(0.5 + 0.5*sin(phase));

  // Distance attenuation (brighter when closer)
  let atten   = 1.0/(1.0 + dist*0.00075);
  let bright  = pattern * atten;

  o.cp     = uni.view_proj * vec4f(fpos,1);
  o.uv     = (qv + 1.0)*0.5;
  o.color  = col;
  o.bright = bright;
  return o;
}

@fragment fn fs(in:VOut) -> @location(0) vec4f {
  let d     = length(in.uv - 0.5)*2.0;
  if (d > 1.0) { discard; }
  let ring  = 1.0 - smoothstep(0.55,1.0,d);
  let core  = 1.0 - smoothstep(0.0,0.22,d);
  let alpha = ring * in.bright;
  // HDR output: core > 1 drives bloom
  let hdr   = in.color * (ring + core*2.2) * in.bright * 2.8;
  return vec4f(hdr, alpha);
}
`;

/* ============================================================
   WGSL – BLOOM THRESHOLD (extract bright pixels)
   ============================================================ */
const BLOOM_THRESHOLD_SHADER = /* wgsl */`
@group(0) @binding(0) var tex : texture_2d<f32>;
@group(0) @binding(1) var smp : sampler;

struct VSOut { @builtin(position) pos:vec4f, @location(0) uv:vec2f }

@vertex fn vs(@builtin(vertex_index) vi:u32) -> VSOut {
  const pts = array<vec2f,3>(vec2f(-1,-1),vec2f(3,-1),vec2f(-1,3));
  var o:VSOut; o.pos=vec4f(pts[vi],0,1); o.uv=pts[vi]*0.5+0.5; return o;
}

@fragment fn fs(in:VSOut) -> @location(0) vec4f {
  var uv = in.uv; uv.y = 1.0-uv.y;
  let c   = textureSample(tex,smp,uv).rgb;
  let lum = dot(c,vec3f(0.2126,0.7152,0.0722));
  let t   = smoothstep(0.75,1.4,lum);
  return vec4f(c*t,1.0);
}
`;

/* ============================================================
   WGSL – BLOOM BLUR (horizontal + vertical via uniform flag)
   ============================================================ */
const BLOOM_BLUR_SHADER = /* wgsl */`
struct BlurUni { texel:vec2f, horizontal:u32, pad:u32 }
@group(0) @binding(0) var<uniform> buni : BlurUni;
@group(0) @binding(1) var tex : texture_2d<f32>;
@group(0) @binding(2) var smp : sampler;

struct VSOut { @builtin(position) pos:vec4f, @location(0) uv:vec2f }

@vertex fn vs(@builtin(vertex_index) vi:u32) -> VSOut {
  const pts = array<vec2f,3>(vec2f(-1,-1),vec2f(3,-1),vec2f(-1,3));
  var o:VSOut; o.pos=vec4f(pts[vi],0,1); o.uv=pts[vi]*0.5+0.5; return o;
}

@fragment fn fs(in:VSOut) -> @location(0) vec4f {
  var uv = in.uv; uv.y = 1.0-uv.y;
  let d  = select(vec2f(0,buni.texel.y), vec2f(buni.texel.x,0),
                  buni.horizontal != 0u);
  const W = array<f32,5>(0.2270,0.1945,0.1216,0.0540,0.0162);
  var c   = textureSample(tex,smp,uv).rgb * W[0];
  for (var i=1; i<5; i++) {
    let off = f32(i)*d;
    c += textureSample(tex,smp,uv+off).rgb * W[i];
    c += textureSample(tex,smp,uv-off).rgb * W[i];
  }
  return vec4f(c,1.0);
}
`;

/* ============================================================
   WGSL – BLOOM COMPOSITE + TONEMAPPING
   ============================================================ */
const COMPOSITE_SHADER = /* wgsl */`
@group(0) @binding(0) var scene_tex : texture_2d<f32>;
@group(0) @binding(1) var bloom_tex : texture_2d<f32>;
@group(0) @binding(2) var smp       : sampler;

struct VSOut { @builtin(position) pos:vec4f, @location(0) uv:vec2f }

@vertex fn vs(@builtin(vertex_index) vi:u32) -> VSOut {
  const pts = array<vec2f,3>(vec2f(-1,-1),vec2f(3,-1),vec2f(-1,3));
  var o:VSOut; o.pos=vec4f(pts[vi],0,1); o.uv=pts[vi]*0.5+0.5; return o;
}

fn aces(x:vec3f)->vec3f {
  let a=2.51; let b=0.03; let c=2.43; let d=0.59; let e=0.14;
  return clamp((x*(a*x+b))/(x*(c*x+d)+e),vec3f(0),vec3f(1));
}

@fragment fn fs(in:VSOut) -> @location(0) vec4f {
  var uv = in.uv; uv.y = 1.0-uv.y;
  let scene = textureSample(scene_tex,smp,uv).rgb;
  let bloom = textureSample(bloom_tex,smp,uv).rgb;
  let hdr   = scene + bloom*1.8;
  return vec4f(aces(hdr),1.0);
}
`;

/* ============================================================
   MATH UTILITIES
   ============================================================ */
function v3(x,y,z){return[x,y,z];}
function v3len(a){return Math.sqrt(a[0]**2+a[1]**2+a[2]**2);}
function v3norm(a){const l=v3len(a)||1;return[a[0]/l,a[1]/l,a[2]/l];}
function v3cross(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}
function v3dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function v3sub(a,b){return[a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
function v3add(a,b){return[a[0]+b[0],a[1]+b[1],a[2]+b[2]];}
function v3scale(a,s){return[a[0]*s,a[1]*s,a[2]*s];}

// Column-major mat4
function mat4lookAt(eye,tgt,up){
  const f=v3norm(v3sub(tgt,eye));
  const r=v3norm(v3cross(f,up));
  const u=v3cross(r,f);
  return new Float32Array([
    r[0],u[0],-f[0],0,
    r[1],u[1],-f[1],0,
    r[2],u[2],-f[2],0,
    -v3dot(r,eye),-v3dot(u,eye),v3dot(f,eye),1
  ]);
}

// WebGPU perspective: z in [0,1]
function mat4persp(fovy,asp,near,far){
  const f=1/Math.tan(fovy/2), rng=1/(near-far);
  return new Float32Array([
    f/asp,0,0,0,
    0,f,0,0,
    0,0,far*rng,-1,
    0,0,near*far*rng,0
  ]);
}

function mat4mul(a,b){
  const o=new Float32Array(16);
  for(let c=0;c<4;c++)for(let r=0;r<4;r++){
    let s=0;for(let k=0;k<4;k++)s+=a[r+k*4]*b[k+c*4];
    o[r+c*4]=s;
  }
  return o;
}

function mat4inv(m){
  // Standard 4×4 matrix inversion via cofactor expansion (column-major input/output)
  const t=new Float32Array(16);
  const
    m00=m[0],m10=m[1],m20=m[2],m30=m[3],
    m01=m[4],m11=m[5],m21=m[6],m31=m[7],
    m02=m[8],m12=m[9],m22=m[10],m32=m[11],
    m03=m[12],m13=m[13],m23=m[14],m33=m[15];
  const det=
    m00*(m11*(m22*m33-m23*m32)-m12*(m21*m33-m23*m31)+m13*(m21*m32-m22*m31))
   -m01*(m10*(m22*m33-m23*m32)-m12*(m20*m33-m23*m30)+m13*(m20*m32-m22*m30))
   +m02*(m10*(m21*m33-m23*m31)-m11*(m20*m33-m23*m30)+m13*(m20*m31-m21*m30))
   -m03*(m10*(m21*m32-m22*m31)-m11*(m20*m32-m22*m30)+m12*(m20*m31-m21*m30));
  if(!det)return m;
  const di=1/det;
  t[0] =( m11*(m22*m33-m23*m32)-m12*(m21*m33-m23*m31)+m13*(m21*m32-m22*m31))*di;
  t[1] =(-m01*(m22*m33-m23*m32)+m02*(m21*m33-m23*m31)-m03*(m21*m32-m22*m31))*di;
  t[2] =( m01*(m12*m33-m13*m32)-m02*(m11*m33-m13*m31)+m03*(m11*m32-m12*m31))*di;
  t[3] =(-m01*(m12*m23-m13*m22)+m02*(m11*m23-m13*m21)-m03*(m11*m22-m12*m21))*di;
  t[4] =(-m10*(m22*m33-m23*m32)+m12*(m20*m33-m23*m30)-m13*(m20*m32-m22*m30))*di;
  t[5] =( m00*(m22*m33-m23*m32)-m02*(m20*m33-m23*m30)+m03*(m20*m32-m22*m30))*di;
  t[6] =(-m00*(m12*m33-m13*m32)+m02*(m10*m33-m13*m30)-m03*(m10*m32-m12*m30))*di;
  t[7] =( m00*(m12*m23-m13*m22)-m02*(m10*m23-m13*m20)+m03*(m10*m22-m12*m20))*di;
  t[8] =( m10*(m21*m33-m23*m31)-m11*(m20*m33-m23*m30)+m13*(m20*m31-m21*m30))*di;
  t[9] =(-m00*(m21*m33-m23*m31)+m01*(m20*m33-m23*m30)-m03*(m20*m31-m21*m30))*di;
  t[10]=( m00*(m11*m33-m13*m31)-m01*(m10*m33-m13*m30)+m03*(m10*m31-m11*m30))*di;
  t[11]=(-m00*(m11*m23-m13*m21)+m01*(m10*m23-m13*m20)-m03*(m10*m21-m11*m20))*di;
  t[12]=(-m10*(m21*m32-m22*m31)+m11*(m20*m32-m22*m30)-m12*(m20*m31-m21*m30))*di;
  t[13]=( m00*(m21*m32-m22*m31)-m01*(m20*m32-m22*m30)+m02*(m20*m31-m21*m30))*di;
  t[14]=(-m00*(m11*m32-m12*m31)+m01*(m10*m32-m12*m30)-m02*(m10*m31-m11*m30))*di;
  t[15]=( m00*(m11*m22-m12*m21)-m01*(m10*m22-m12*m20)+m02*(m10*m21-m11*m20))*di;
  return t;
}

function extractFrustum(vp){
  // vp is column-major Float32Array[16]
  // Row i (0-based) of vp = [vp[i], vp[i+4], vp[i+8], vp[i+12]]
  const row=(i)=>[vp[i],vp[i+4],vp[i+8],vp[i+12]];
  const r0=row(0),r1=row(1),r2=row(2),r3=row(3);
  const planes=[
    [r3[0]+r0[0],r3[1]+r0[1],r3[2]+r0[2],r3[3]+r0[3]], // Left
    [r3[0]-r0[0],r3[1]-r0[1],r3[2]-r0[2],r3[3]-r0[3]], // Right
    [r3[0]+r1[0],r3[1]+r1[1],r3[2]+r1[2],r3[3]+r1[3]], // Bottom
    [r3[0]-r1[0],r3[1]-r1[1],r3[2]-r1[2],r3[3]-r1[3]], // Top
    [r2[0],r2[1],r2[2],r2[3]],                          // Near (WebGPU z=0)
    [r3[0]-r2[0],r3[1]-r2[1],r3[2]-r2[2],r3[3]-r2[3]], // Far
  ];
  return planes.map(p=>{
    const l=Math.sqrt(p[0]**2+p[1]**2+p[2]**2)||1;
    return p.map(x=>x/l);
  });
}

/* ============================================================
   GEOMETRY – UV SPHERE
   ============================================================ */
function genSphere(radius,rings,segs){
  const verts=[],norms=[],idxs=[];
  for(let r=0;r<=rings;r++){
    const th=r*Math.PI/rings;
    const sT=Math.sin(th),cT=Math.cos(th);
    for(let s=0;s<=segs;s++){
      const ph=s*2*Math.PI/segs;
      const x=radius*sT*Math.cos(ph);
      const y=radius*sT*Math.sin(ph);
      const z=radius*cT;
      verts.push(x,y,z);
      norms.push(x/radius,y/radius,z/radius);
    }
  }
  for(let r=0;r<rings;r++){
    for(let s=0;s<segs;s++){
      const a=r*(segs+1)+s, b=a+segs+1;
      idxs.push(a,b,a+1,b,b+1,a+1);
    }
  }
  return{verts:new Float32Array(verts),norms:new Float32Array(norms),
         idxs:new Uint32Array(idxs)};
}

/* ============================================================
   ORBITAL ELEMENT GENERATION (1 024 × 1 024 = 1 048 576)
   ============================================================ */
function genOrbitalElements(){
  const data=new Float32Array(NUM_SAT*4);
  const shells=[53*DEG, 70*DEG, 97.6*DEG, 30*DEG]; // inclination shells
  for(let p=0;p<NUM_PLANES;p++){
    const raan=(p/NUM_PLANES)*2*Math.PI;
    const shell=Math.floor(p/(NUM_PLANES/4));
    const inc=shells[shell]+(Math.random()-0.5)*0.008;
    for(let s=0;s<SAT_PER_PLANE;s++){
      const idx=(p*SAT_PER_PLANE+s)*4;
      const m0=(s/SAT_PER_PLANE)*2*Math.PI;
      data[idx+0]=raan;
      data[idx+1]=inc;
      data[idx+2]=m0;
      // Color index: rainbow by plane (0-6), pulsing phase encoded in fractional part
      data[idx+3]=(p*7/NUM_PLANES)|0;
    }
  }
  return data;
}

/* ============================================================
   CPU-SIDE ORBITAL POSITION (for camera follow)
   ============================================================ */
function cpuSatPos(elem,idx,t){
  const i=idx*4;
  const raan=elem[i],inc=elem[i+1],m0=elem[i+2];
  const M=m0+MEAN_MOTION*t;
  const cM=Math.cos(M),sM=Math.sin(M);
  const cR=Math.cos(raan),sR=Math.sin(raan);
  const cI=Math.cos(inc),sI=Math.sin(inc);
  return[
    ORBIT_R*(cR*cM-sR*sM*cI),
    ORBIT_R*(sR*cM+cR*sM*cI),
    ORBIT_R*sM*sI
  ];
}
function cpuSatVel(elem,idx,t){
  const i=idx*4;
  const raan=elem[i],inc=elem[i+1],m0=elem[i+2];
  const M=m0+MEAN_MOTION*t;
  const cM=Math.cos(M),sM=Math.sin(M);
  const cR=Math.cos(raan),sR=Math.sin(raan);
  const cI=Math.cos(inc),sI=Math.sin(inc);
  // dpos/dM (normalized velocity direction)
  return v3norm([
    -(cR*sM+sR*cM*cI),
    -(sR*sM-cR*cM*cI),
    cM*sI
  ]);
}

/* ============================================================
   SIMULATION CLASS
   ============================================================ */
class ColossusSimulation {
  constructor(canvas){
    this.canvas=canvas;
    this.viewMode=0;  // 0=Horizon, 1=God, 2=Fleet
    this.godYaw=0; this.godPitch=0.35;
    this.godDist=25000;
    this.lastTime=0; this.frameCount=0; this.fpsTime=0; this.fps=0;
    this.orbElem=genOrbitalElements();
    // Mouse orbit for God view
    this.mouse={down:false,lx:0,ly:0};
    canvas.addEventListener('mousedown',e=>{this.mouse.down=true;this.mouse.lx=e.clientX;this.mouse.ly=e.clientY;});
    window.addEventListener('mouseup',()=>this.mouse.down=false);
    window.addEventListener('mousemove',e=>{
      if(!this.mouse.down||this.viewMode!==1)return;
      const dx=e.clientX-this.mouse.lx,dy=e.clientY-this.mouse.ly;
      this.godYaw+=dx*0.004; this.godPitch=Math.max(-1.4,Math.min(1.4,this.godPitch-dy*0.004));
      this.mouse.lx=e.clientX; this.mouse.ly=e.clientY;
    });
    canvas.addEventListener('wheel',e=>{
      if(this.viewMode!==1)return;
      this.godDist=Math.max(8000,Math.min(60000,this.godDist+e.deltaY*10));
    });
  }

  /* ---- PUBLIC -------------------------------------------- */
  setView(m){
    this.viewMode=m;
    const names=['720km Horizon','God View','Fleet POV'];
    document.getElementById('s-view').textContent='View     : '+names[m];
    ['btn0','btn1','btn2'].forEach((id,i)=>{
      document.getElementById(id).classList.toggle('active',i===m);
    });
  }

  /* ---- INIT ---------------------------------------------- */
  async init(){
    if(!navigator.gpu) throw new Error('WebGPU not supported in this browser.');
    const adapter=await navigator.gpu.requestAdapter({powerPreference:'high-performance'});
    if(!adapter) throw new Error('No WebGPU adapter found.');
    this.device=await adapter.requestDevice({
      requiredLimits:{
        maxStorageBufferBindingSize:Math.min(adapter.limits.maxStorageBufferBindingSize,
                                             NUM_SAT*16+16),
        maxBufferSize:Math.min(adapter.limits.maxBufferSize, NUM_SAT*16+16),
      }
    });
    const d=this.device;

    this.ctx=this.canvas.getContext('webgpu');
    this.fmt=navigator.gpu.getPreferredCanvasFormat();
    this.ctx.configure({device:d,format:this.fmt,alphaMode:'opaque'});

    this._initBuffers();
    this._initTextures();
    await this._initPipelines();
  }

  /* ---- BUFFERS ------------------------------------------- */
  _initBuffers(){
    const d=this.device;

    // Uniform buffer (256 bytes)
    this.uniBuf=d.createBuffer({size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});

    // Orbital elements (read-only storage)
    this.orbBuf=d.createBuffer({
      size:this.orbElem.byteLength,
      usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,
    });
    d.queue.writeBuffer(this.orbBuf,0,this.orbElem);

    // Satellite positions (read-write storage)
    this.satBuf=d.createBuffer({
      size:NUM_SAT*16, // vec4f per satellite
      usage:GPUBufferUsage.STORAGE,
    });

    // Two separate bloom-uniform buffers (H and V), written once when resolution changes
    this.bloomUniBufH=d.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});
    this.bloomUniBufV=d.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});

    // Earth geometry
    const sphere=genSphere(EARTH_R,64,64);
    this.earthVCount=sphere.verts.length/3;
    this.earthICount=sphere.idxs.length;

    // Interleaved vertex buffer: pos(3) + norm(3) = 6 floats per vertex
    const interleaved=new Float32Array(this.earthVCount*6);
    for(let i=0;i<this.earthVCount;i++){
      interleaved[i*6+0]=sphere.verts[i*3+0];
      interleaved[i*6+1]=sphere.verts[i*3+1];
      interleaved[i*6+2]=sphere.verts[i*3+2];
      interleaved[i*6+3]=sphere.norms[i*3+0];
      interleaved[i*6+4]=sphere.norms[i*3+1];
      interleaved[i*6+5]=sphere.norms[i*3+2];
    }
    this.earthVBuf=d.createBuffer({
      size:interleaved.byteLength,
      usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST
    });
    d.queue.writeBuffer(this.earthVBuf,0,interleaved);

    this.earthIBuf=d.createBuffer({
      size:sphere.idxs.byteLength,
      usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST
    });
    d.queue.writeBuffer(this.earthIBuf,0,sphere.idxs);
  }

  /* ---- TEXTURES ------------------------------------------ */
  _initTextures(){
    this._createRTTextures();
  }

  _createRTTextures(){
    const d=this.device;
    const w=this.canvas.width,h=this.canvas.height;

    const mkTex=(fmt,usage)=>d.createTexture({
      size:[w,h],format:fmt,
      usage:usage|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT
    });

    this.hdrTex   =mkTex('rgba16float',GPUTextureUsage.TEXTURE_BINDING);
    this.depthTex =d.createTexture({size:[w,h],format:'depth24plus',
                    usage:GPUTextureUsage.RENDER_ATTACHMENT});
    this.bloomA   =mkTex('rgba16float',GPUTextureUsage.TEXTURE_BINDING);
    this.bloomB   =mkTex('rgba16float',GPUTextureUsage.TEXTURE_BINDING);

    const lDesc={magFilter:'linear',minFilter:'linear',addressModeU:'clamp-to-edge',
                  addressModeV:'clamp-to-edge'};
    this.linearSampler=d.createSampler(lDesc);

    // Cache texture views (avoids createView() every frame)
    this.hdrView  =this.hdrTex.createView();
    this.depthView=this.depthTex.createView();
    this.bAView   =this.bloomA.createView();
    this.bBView   =this.bloomB.createView();

    // Write per-resolution bloom uniforms into the two dedicated buffers
    this._updateBloomUniforms(w,h);
  }

  _updateBloomUniforms(w,h){
    const d=this.device;
    const mkBuf=(horiz)=>{
      const ab=new ArrayBuffer(32);
      const f=new Float32Array(ab);
      const u=new Uint32Array(ab);
      f[0]=1/w; f[1]=1/h; u[2]=horiz?1:0; u[3]=0;
      return ab;
    };
    d.queue.writeBuffer(this.bloomUniBufH,0,mkBuf(true));
    d.queue.writeBuffer(this.bloomUniBufV,0,mkBuf(false));
  }

  /* ---- PIPELINES ----------------------------------------- */
  async _initPipelines(){
    const d=this.device;

    // ---- Compute: orbital mechanics ----
    this.computePL=d.createPipelineLayout({
      bindGroupLayouts:[d.createBindGroupLayout({entries:[
        {binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:'uniform'}},
        {binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:'read-only-storage'}},
        {binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:'storage'}},
      ]})]
    });
    this.computePipe=d.createComputePipeline({
      layout:this.computePL,
      compute:{module:d.createShaderModule({code:ORBITAL_CS}),entryPoint:'main'}
    });
    this.computeBG=d.createBindGroup({
      layout:this.computePipe.getBindGroupLayout(0),
      entries:[
        {binding:0,resource:{buffer:this.uniBuf}},
        {binding:1,resource:{buffer:this.orbBuf}},
        {binding:2,resource:{buffer:this.satBuf}},
      ]
    });

    // ---- Shared render layouts ----
    const uniOnlyBGL=d.createBindGroupLayout({entries:[
      {binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,
       buffer:{type:'uniform'}}
    ]});
    const uniStorageBGL=d.createBindGroupLayout({entries:[
      {binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,
       buffer:{type:'uniform'}},
      {binding:1,visibility:GPUShaderStage.VERTEX,
       buffer:{type:'read-only-storage'}},
    ]});
    const uniOnlyPL=d.createPipelineLayout({bindGroupLayouts:[uniOnlyBGL]});
    const uniStoragePL=d.createPipelineLayout({bindGroupLayouts:[uniStorageBGL]});

    // Vertex buffer layout: pos(3f) + nrm(3f)
    const earthVBL={arrayStride:24,attributes:[
      {shaderLocation:0,offset:0, format:'float32x3'},
      {shaderLocation:1,offset:12,format:'float32x3'},
    ]};

    const hdrTarget=[{format:'rgba16float',blend:{
      color:{srcFactor:'one',dstFactor:'one-minus-src-alpha',operation:'add'},
      alpha:{srcFactor:'one',dstFactor:'one-minus-src-alpha',operation:'add'},
    }}];
    const hdrAddTarget=[{format:'rgba16float',blend:{
      color:{srcFactor:'src-alpha',dstFactor:'one',operation:'add'},
      alpha:{srcFactor:'one',dstFactor:'one',operation:'add'},
    }}];

    // ---- Stars pipeline (no depth) ----
    const starsMod=d.createShaderModule({code:STARS_SHADER});
    this.starsPipe=d.createRenderPipeline({
      layout:uniOnlyPL,
      vertex:{module:starsMod,entryPoint:'vs'},
      fragment:{module:starsMod,entryPoint:'fs',targets:[{format:'rgba16float'}]},
      primitive:{topology:'triangle-list'},
      depthStencil:{format:'depth24plus',depthWriteEnabled:false,
                    depthCompare:'always'},
    });
    this.starsBG=d.createBindGroup({
      layout:this.starsPipe.getBindGroupLayout(0),
      entries:[{binding:0,resource:{buffer:this.uniBuf}}]
    });

    // ---- Earth pipeline ----
    const earthMod=d.createShaderModule({code:EARTH_SHADER});
    this.earthPipe=d.createRenderPipeline({
      layout:uniOnlyPL,
      vertex:{module:earthMod,entryPoint:'vs',buffers:[earthVBL]},
      fragment:{module:earthMod,entryPoint:'fs',targets:[{format:'rgba16float'}]},
      primitive:{topology:'triangle-list',cullMode:'back'},
      depthStencil:{format:'depth24plus',depthWriteEnabled:true,
                    depthCompare:'less'},
    });
    this.earthBG=d.createBindGroup({
      layout:this.earthPipe.getBindGroupLayout(0),
      entries:[{binding:0,resource:{buffer:this.uniBuf}}]
    });

    // ---- Atmosphere pipeline (additive blend) ----
    const atmMod=d.createShaderModule({code:ATM_SHADER});
    this.atmPipe=d.createRenderPipeline({
      layout:uniOnlyPL,
      vertex:{module:atmMod,entryPoint:'vs',buffers:[earthVBL]},
      fragment:{module:atmMod,entryPoint:'fs',targets:[{format:'rgba16float',blend:{
        color:{srcFactor:'src-alpha',dstFactor:'one',operation:'add'},
        alpha:{srcFactor:'one',dstFactor:'one',operation:'add'},
      }}]},
      primitive:{topology:'triangle-list',cullMode:'front'},
      depthStencil:{format:'depth24plus',depthWriteEnabled:false,
                    depthCompare:'less'},
    });
    this.atmBG=d.createBindGroup({
      layout:this.atmPipe.getBindGroupLayout(0),
      entries:[{binding:0,resource:{buffer:this.uniBuf}}]
    });

    // ---- Satellite pipeline (additive blend) ----
    const satMod=d.createShaderModule({code:SAT_SHADER});
    this.satPipe=d.createRenderPipeline({
      layout:uniStoragePL,
      vertex:{module:satMod,entryPoint:'vs'},
      fragment:{module:satMod,entryPoint:'fs',targets:[{format:'rgba16float',blend:{
        color:{srcFactor:'src-alpha',dstFactor:'one',operation:'add'},
        alpha:{srcFactor:'one',dstFactor:'one',operation:'add'},
      }}]},
      primitive:{topology:'triangle-list'},
      depthStencil:{format:'depth24plus',depthWriteEnabled:false,
                    depthCompare:'less'},
    });
    this.satBG=d.createBindGroup({
      layout:this.satPipe.getBindGroupLayout(0),
      entries:[
        {binding:0,resource:{buffer:this.uniBuf}},
        {binding:1,resource:{buffer:this.satBuf}},
      ]
    });

    // ---- Bloom pipeline layout ----
    const bloomBGL=d.createBindGroupLayout({entries:[
      {binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:'uniform'}},
      {binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:'float'}},
      {binding:2,visibility:GPUShaderStage.FRAGMENT,sampler:{type:'filtering'}},
    ]});
    const bloomPL=d.createPipelineLayout({bindGroupLayouts:[bloomBGL]});

    // ---- Bloom threshold pipeline ----
    const thrBGL=d.createBindGroupLayout({entries:[
      {binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:'float'}},
      {binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:'filtering'}},
    ]});
    const thrPL=d.createPipelineLayout({bindGroupLayouts:[thrBGL]});
    const thrMod=d.createShaderModule({code:BLOOM_THRESHOLD_SHADER});
    this.thrPipe=d.createRenderPipeline({
      layout:thrPL,
      vertex:{module:thrMod,entryPoint:'vs'},
      fragment:{module:thrMod,entryPoint:'fs',targets:[{format:'rgba16float'}]},
      primitive:{topology:'triangle-list'},
    });

    // ---- Bloom blur pipeline ----
    const blurMod=d.createShaderModule({code:BLOOM_BLUR_SHADER});
    this.blurPipe=d.createRenderPipeline({
      layout:bloomPL,
      vertex:{module:blurMod,entryPoint:'vs'},
      fragment:{module:blurMod,entryPoint:'fs',targets:[{format:'rgba16float'}]},
      primitive:{topology:'triangle-list'},
    });

    // ---- Composite pipeline ----
    const cmpBGL=d.createBindGroupLayout({entries:[
      {binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:'float'}},
      {binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:'float'}},
      {binding:2,visibility:GPUShaderStage.FRAGMENT,sampler:{type:'filtering'}},
    ]});
    const cmpPL=d.createPipelineLayout({bindGroupLayouts:[cmpBGL]});
    const cmpMod=d.createShaderModule({code:COMPOSITE_SHADER});
    this.cmpPipe=d.createRenderPipeline({
      layout:cmpPL,
      vertex:{module:cmpMod,entryPoint:'vs'},
      fragment:{module:cmpMod,entryPoint:'fs',targets:[{format:this.fmt}]},
      primitive:{topology:'triangle-list'},
    });

    // Bind groups that reference textures (rebuilt on resize)
    this._rebuildTextureBindGroups();
  }

  _rebuildTextureBindGroups(){
    const d=this.device;
    const hdrV=this.hdrView;
    const bAV=this.bAView;
    const bBV=this.bBView;
    const sm=this.linearSampler;

    this.thrBG=d.createBindGroup({
      layout:this.thrPipe.getBindGroupLayout(0),
      entries:[{binding:0,resource:hdrV},{binding:1,resource:sm}]
    });
    // H-blur: reads bloomA (threshold result) → writes bloomB
    this.blurHBG=d.createBindGroup({
      layout:this.blurPipe.getBindGroupLayout(0),
      entries:[
        {binding:0,resource:{buffer:this.bloomUniBufH}},
        {binding:1,resource:bAV},
        {binding:2,resource:sm},
      ]
    });
    // V-blur: reads bloomB (H-blur result) → writes bloomA
    this.blurVBG=d.createBindGroup({
      layout:this.blurPipe.getBindGroupLayout(0),
      entries:[
        {binding:0,resource:{buffer:this.bloomUniBufV}},
        {binding:1,resource:bBV},
        {binding:2,resource:sm},
      ]
    });
    // Composite: scene(hdr) + bloom(bloomA, final V-blur result)
    this.cmpBG=d.createBindGroup({
      layout:this.cmpPipe.getBindGroupLayout(0),
      entries:[
        {binding:0,resource:hdrV},
        {binding:1,resource:bAV},
        {binding:2,resource:sm},
      ]
    });
  }

  /* ---- RESIZE -------------------------------------------- */
  handleResize(){
    const w=this.canvas.clientWidth*devicePixelRatio|0;
    const h=this.canvas.clientHeight*devicePixelRatio|0;
    if(w===this.canvas.width&&h===this.canvas.height)return;
    this.canvas.width=w; this.canvas.height=h;
    // Destroy old textures
    this.hdrTex.destroy(); this.depthTex.destroy();
    this.bloomA.destroy(); this.bloomB.destroy();
    this._createRTTextures();          // also calls _updateBloomUniforms
    this._rebuildTextureBindGroups();
  }

  /* ---- UNIFORM UPDATE ------------------------------------ */
  _writeUniforms(t,dt){
    const d=this.device;
    const w=this.canvas.width,h=this.canvas.height;

    // Compute camera matrices
    let eye,tgt,up;
    const vm=this.viewMode;

    if(vm===0){
      // 720km Horizon: camera on +X side looking in +Y direction
      eye=[CAM_R,0,0];
      tgt=[CAM_R,1000,0];
      up=[0,0,1];
    } else if(vm===1){
      // God View: orbiting above
      const pitch=this.godPitch, yaw=this.godYaw;
      const cP=Math.cos(pitch),sP=Math.sin(pitch);
      const cY=Math.cos(yaw), sY=Math.sin(yaw);
      eye=v3scale([cP*cY,cP*sY,sP],this.godDist);
      tgt=[0,0,0];
      up=[0,0,1];
      // Avoid gimbal lock near poles
      if(Math.abs(pitch)>1.35)up=[Math.cos(yaw),Math.sin(yaw),0];
    } else {
      // Fleet POV: follow satellite #0
      const sp=cpuSatPos(this.orbElem,0,t);
      const sv=cpuSatVel(this.orbElem,0,t);
      const radial=v3norm(sp);
      // Camera slightly above satellite, looking forward in orbital direction
      eye=v3add(sp,v3scale(radial,15));
      tgt=v3add(eye,sv);
      up=radial;
    }

    const view=mat4lookAt(eye,tgt,up);
    const proj=mat4persp(60*DEG,w/h,10,50000);
    const vp=mat4mul(proj,view);

    // Camera right/up for billboards (from view matrix rows)
    const camRight=[view[0],view[4],view[8]];
    const camUp   =[view[1],view[5],view[9]];

    const frustum=extractFrustum(vp);

    // Write to ArrayBuffer
    const ab=new ArrayBuffer(256);
    const f=new Float32Array(ab);
    const u=new Uint32Array(ab);

    f.set(vp,0);                         // view_proj  offset 0
    f[16]=eye[0];f[17]=eye[1];f[18]=eye[2];f[19]=1; // camera_pos offset 64
    f[20]=camRight[0];f[21]=camRight[1];f[22]=camRight[2];f[23]=0;
    f[24]=camUp[0];   f[25]=camUp[1];   f[26]=camUp[2];   f[27]=0;
    f[28]=t;          f[29]=dt;          u[30]=vm;          u[31]=0;
    for(let p=0;p<6;p++){
      f[32+p*4]=frustum[p][0];
      f[33+p*4]=frustum[p][1];
      f[34+p*4]=frustum[p][2];
      f[35+p*4]=frustum[p][3];
    }
    f[56]=w; f[57]=h; f[58]=0; f[59]=0;

    d.queue.writeBuffer(this.uniBuf,0,ab);

    return{w,h};
  }

  /* ---- RENDER FRAME -------------------------------------- */
  render(ts){
    const t=ts*0.001;
    const dt=Math.min(t-this.lastTime,0.1);
    this.lastTime=t;

    // FPS
    this.frameCount++;
    if(t-this.fpsTime>=0.5){
      this.fps=Math.round(this.frameCount/(t-this.fpsTime));
      this.frameCount=0; this.fpsTime=t;
      document.getElementById('s-fps').textContent='FPS      : '+this.fps;
    }

    this.handleResize();
    const{w,h}=this._writeUniforms(t,dt);

    const d=this.device;
    const enc=d.createCommandEncoder();

    /* --- PASS 1: Compute orbital positions --- */
    {
      const cp=enc.beginComputePass();
      cp.setPipeline(this.computePipe);
      cp.setBindGroup(0,this.computeBG);
      cp.dispatchWorkgroups(Math.ceil(NUM_SAT/64));
      cp.end();
    }

    /* --- PASS 2: Scene → HDR texture --- */
    {
      const rp=enc.beginRenderPass({
        colorAttachments:[{
          view:this.hdrView,
          clearValue:{r:0,g:0,b:0.02,a:1},
          loadOp:'clear',storeOp:'store',
        }],
        depthStencilAttachment:{
          view:this.depthView,
          depthClearValue:1,depthLoadOp:'clear',depthStoreOp:'store',
        }
      });

      // Stars
      rp.setPipeline(this.starsPipe);
      rp.setBindGroup(0,this.starsBG);
      rp.draw(3);

      // Earth
      rp.setPipeline(this.earthPipe);
      rp.setBindGroup(0,this.earthBG);
      rp.setVertexBuffer(0,this.earthVBuf);
      rp.setIndexBuffer(this.earthIBuf,'uint32');
      rp.drawIndexed(this.earthICount);

      // Atmosphere
      rp.setPipeline(this.atmPipe);
      rp.setBindGroup(0,this.atmBG);
      rp.setVertexBuffer(0,this.earthVBuf);
      rp.setIndexBuffer(this.earthIBuf,'uint32');
      rp.drawIndexed(this.earthICount);

      // Satellites (instanced billboards)
      rp.setPipeline(this.satPipe);
      rp.setBindGroup(0,this.satBG);
      rp.draw(6,NUM_SAT);

      rp.end();
    }

    /* --- PASS 3: Bloom threshold → bloomA --- */
    {
      const rp=enc.beginRenderPass({
        colorAttachments:[{
          view:this.bAView,
          clearValue:{r:0,g:0,b:0,a:1},
          loadOp:'clear',storeOp:'store',
        }]
      });
      rp.setPipeline(this.thrPipe);
      rp.setBindGroup(0,this.thrBG);
      rp.draw(3);
      rp.end();
    }

    /* --- PASS 4: Horizontal blur bloomA → bloomB --- */
    {
      const rp=enc.beginRenderPass({
        colorAttachments:[{
          view:this.bBView,
          clearValue:{r:0,g:0,b:0,a:1},
          loadOp:'clear',storeOp:'store',
        }]
      });
      rp.setPipeline(this.blurPipe);
      rp.setBindGroup(0,this.blurHBG);
      rp.draw(3);
      rp.end();
    }

    /* --- PASS 5: Vertical blur bloomB → bloomA --- */
    {
      const rp=enc.beginRenderPass({
        colorAttachments:[{
          view:this.bAView,
          clearValue:{r:0,g:0,b:0,a:1},
          loadOp:'clear',storeOp:'store',
        }]
      });
      rp.setPipeline(this.blurPipe);
      rp.setBindGroup(0,this.blurVBG);
      rp.draw(3);
      rp.end();
    }

    /* --- PASS 6: Composite → swapchain --- */
    {
      const rp=enc.beginRenderPass({
        colorAttachments:[{
          view:this.ctx.getCurrentTexture().createView(),
          clearValue:{r:0,g:0,b:0,a:1},
          loadOp:'clear',storeOp:'store',
        }]
      });
      rp.setPipeline(this.cmpPipe);
      rp.setBindGroup(0,this.cmpBG);
      rp.draw(3);
      rp.end();
    }

    d.queue.submit([enc.finish()]);
  }
}

/* ============================================================
   MAIN
   ============================================================ */
let sim=null;

async function main(){
  const canvas=document.getElementById('canvas');
  canvas.width =window.innerWidth *devicePixelRatio|0;
  canvas.height=window.innerHeight*devicePixelRatio|0;

  try{
    sim=new ColossusSimulation(canvas);
    await sim.init();

    // Update static UI
    document.getElementById('s-alt').textContent  ='Altitude : 720 km';
    document.getElementById('s-fleet').textContent='Fleet    : 1,048,576';

    function frame(ts){ sim.render(ts); requestAnimationFrame(frame); }
    requestAnimationFrame(frame);
  }catch(err){
    const el=document.getElementById('error');
    el.style.display='block';
    el.innerHTML='<b>WebGPU Error</b><br>'+err.message+
      '<br><br>Please use a modern browser with WebGPU enabled (Chrome, Edge, or Firefox Nightly).';
    console.error(err);
  }
}

main();
</script>
</body>
</html>
